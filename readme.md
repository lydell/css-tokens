Overview [![Build Status](https://travis-ci.org/lydell/css-tokens.png?branch=master)](https://travis-ci.org/lydell/css-tokens)
========

A regex that tokenizes CSS.

```js
var cssTokens = require("css-tokens")

// Tokenize a whole string of CSS:
cssString.match(cssTokens)
// [".", "foo", "{", "prop", ":", " ", "foo", ";", "}", "\n", ...]

// Rename the class `foo` to `bar`:
var lastToken
cssString.replace(cssTokens, function(token) {
  if (lastToken === "." && token === "foo") {
    return "bar"
  }
  lastToken = token
  return token
})
// [".", "bar", "{", "prop", ":", " ", "foo", ";", "}", "\n", ...]
```


Installation
============

`npm install css-tokens`

```js
var cssTokens = require("css-tokens")
```


Usage
=====

### `cssTokens` ###

A regex with the `g` flag that matches CSS tokens.

The regex _always_ matches, even invalid CSS and the empty string. For
example, `cssTokens.exec(string)` never returns `null`.

The next match is always directly after the previous. Each token has its own
capturing group.

### `cssTokens.names` ###

An array of names for each token, in the capturing group order.


Invalid code handling
=====================

Unterminated strings are still matched as strings. CSS strings cannot contain
(unescaped) newlines, so unterminated strings simply end at the end of the
line. You may use `/['"]$/.test(matchedStringToken)` to determine if a string
was terminated or not.

Unterminated multi-line comments are also still matched as comments. They
simply go on to the end of the string.

Unterminated unquoted urls are also still matched as unquoted urls. They
continue as long as there are valid characters.

Invalid ASCII characters have their own capturing group.


Limitations
===========

Tokenizing CSS using regexes—in fact, _one single regex_—won’t be
perfect. But that’s not the point either.

The only known “limitation” is the following:

```css
url(http://www.w3.org/2000/svg)
url('http://www.w3.org/2000/svg')
```

The first line is matched as one single token (unquotedUrl), while the second
is matched as four (name + punctuation + string + punctuation). This _could_ be
fixed, but isn’t to simplify the regex.


Build
=====

index.js is generated by running `node generate-index.js`. The regex is written
in regex.coffee. Don’t worry, you don’t need to know anything about
CoffeeScript: regex.coffee should be kept as simple as possible. CoffeeScript
is only used for its block regexes, which have the following benefits:

- Insignificant whitespace.
- Comments.
- No need to escape slashes.
- No need to double-escape everything (as opposed to using `RegExp("regex as a
  string. One backslash: \\\\")`).
- Plenty of syntax highlighters available.

Everything else is written in JavaScript.


License
=======

[The X11 (“MIT”) License](LICENSE).
